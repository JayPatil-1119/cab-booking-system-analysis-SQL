-- 1. Identify customers who have completed the most bookings

SELECT 
    customer.cust_name,
    COUNT(booking.booking_id) AS maximum_booking
FROM
    customer
        JOIN
    booking ON customer.cust_id = booking.cust_id
WHERE
    booking.status = 'completed'
GROUP BY customer.cust_id
ORDER BY maximum_booking DESC
LIMIT 1;

-- 2. Find customers who have canceled more than 30% of their total bookings
SELECT 
    customer.cust_name,
    COUNT(CASE
        WHEN status = 'cancelled' THEN 1
    END) / COUNT(booking.booking_id) > 0.3 AS maximum_cancelled
FROM
    customer
        JOIN
    booking ON customer.cust_id = booking.cust_id
WHERE
    booking.status = 'cancelled'
GROUP BY cust_name
ORDER BY maximum_cancelled DESC
LIMIT 1;
 
select * from booking;

-- 3. Determine the busiest day of the week for bookings. How can the company optimize cab availability on peak days? 

SELECT 
    DAYNAME(booking_time) AS week_of_days,
    COUNT(*) AS busiest_day
FROM
    booking
GROUP BY week_of_days
ORDER BY week_of_days DESC;

-- 4.Identify drivers who have received an average rating below 3.0 in the past three months.

SELECT 
    driver_name, AVG(trip_details.driver_rating) AS below_rating
FROM
    driver
        JOIN
    cabs ON driver.driver_id = cabs.driver_id
        JOIN
    booking ON cabs.cab_id = booking.cab_id
        JOIN
    trip_details ON booking.booking_id = trip_details.booking_id
WHERE
    booking.trip_end_time >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH)
GROUP BY driver.driver_name
HAVING below_rating < 3.0;

-- 5.Find the top 5 drivers who have completed the longest trips in terms of distance

SELECT 
    driver.driver_name, trip_details.distance
FROM
    driver
        JOIN
    cabs ON driver.driver_id = cabs.driver_id
        JOIN
    booking ON cabs.cab_id = booking.cab_id
        JOIN
    trip_details ON booking.booking_id = trip_details.booking_id
ORDER BY trip_details.distance DESC
LIMIT 5;

-- 6.Identify drivers with a high percentage of canceled trips

SELECT 
    driver.driver_name,
    COUNT(CASE
        WHEN booking.status = 'cancelled' THEN 1
    END) * 1.0 / COUNT(booking.booking_id) AS cancellation_rate
FROM
    driver
        JOIN
    cabs ON driver.driver_id = cabs.driver_id
        JOIN
    booking ON booking.cab_id = cabs.cab_id
GROUP BY driver.driver_id
HAVING cancellation_rate > 0.3;

-- 7. Calculate the total revenue generated by completed bookings in the last 6 months.

select * from booking;
select * from Driver;
select * from cabs;
select * from trip_details;

SELECT 
    MONTH(trip_end_time) AS month,
    SUM(trip_details.fare) AS monthly_revenue
FROM
    booking
        JOIN
    trip_details ON booking.booking_id = trip_details.booking_id
WHERE
    booking.status = 'completed'
        AND trip_end_time >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)
GROUP BY month
ORDER BY month;

-- 8. Identify the top 3 most frequently traveled routes based on PickupLocation and DropoffLocation.
select * from booking;
select * from Driver;
select * from cabs;
select * from trip_details;

SELECT 
    pickup_location, dropoff_location, COUNT(*) AS trip_count
FROM
    booking
WHERE
    status = 'completed'
GROUP BY pickup_location , dropoff_location
ORDER BY trip_count DESC
LIMIT 3;

-- 9. Determine if higher-rated drivers tend to complete more trips and earn higher fares. 


SELECT 
    driver.driver_name,
    AVG(trip_details.driver_rating) AS average_rating,
    COUNT(trip_id) AS trip_count,
    SUM(trip_details.fare) AS total_earning
FROM
    driver
        JOIN
    cabs ON driver.driver_id = cabs.driver_id
        JOIN
    booking ON cabs.cab_id = booking.cab_id
        JOIN
    trip_details ON booking.booking_id = trip_details.booking_id
GROUP BY driver.driver_id
ORDER BY trip_count
LIMIT 3;

-- 10. Analyze the average waiting time (difference between booking time and trip start time) for different pickup locations.
select * from booking;
select * from Driver;
select * from cabs;
select * from trip_details;

SELECT 
    pickup_location,
    AVG(TIMESTAMPDIFF(MINUTE,
        booking_time,
        trip_start_time)) AS avg_wait_time
FROM
    booking
WHERE
    status = 'completed'
GROUP BY pickup_location
ORDER BY avg_wait_time;

-- 11. Identify the most common reasons for trip cancellations from customer feedback
select * from feedback;
select * from booking;
SELECT 
    reason_for_cancellation, COUNT(*) AS occurance
FROM
    feedback
        JOIN
    booking ON feedback.booking_id = booking.booking_id
WHERE
    status = 'cancelled'
GROUP BY reason_for_cancellation
ORDER BY occurance DESC;

-- 12. Find out whether shorter trips (low-distance) contribute significantly to revenue
select * from booking;
select * from Driver;
select * from cabs;
select * from trip_details;

SELECT 
    SUM(CASE
        WHEN distance < 10 THEN fare
        ELSE 0
    END) AS short_trip_revenue,
    SUM(fare) AS total_revenue,
    SUM(CASE
        WHEN distance < 10 THEN fare
        ELSE 0
    END) * 100.0 / SUM(fare) AS percentage_short_trip_revenue
FROM
    trip_details;
  use project;  
--  13. Compare the revenue generated from 'Sedan' and 'SUV' cabs
select * from cabs;
select * from trip_details;
select * from booking;

SELECT 
    cabtype, SUM(trip_details.fare) AS revenue
FROM
    trip_details
        JOIN
    booking ON trip_details.booking_id = booking.booking_id
        JOIN
    cabs ON booking.cab_id = cabs.cab_id
GROUP BY cabtype;

-- 14. Predict which customers are likely to stop using the service based on their last booking date and frequency of rides
select * from customer;
select * from booking;
select * from trip_details;

SELECT 
    customer.cust_name,
    MAX(booking.booking_time) AS last_booking,
    COUNT(booking.booking_id) AS total_booking
FROM
    customer
        JOIN
    booking ON customer.cust_id = booking.cust_id
GROUP BY customer.cust_id
HAVING last_booking < DATE_SUB(CURDATE(), INTERVAL 60 DAY)
    OR total_booking < 5;
    
-- 15. Analyze whether weekend bookings differ significantly from weekday bookings
select * from booking;
select * from trip_details;
select 
	case 
		when dayofweek(booking_time) in(1,7) then "weekend"
        else "weekday"
	end as day_type, count(*) as bookings, sum(fare) as revenue from booking
    join trip_details on booking.booking_id = trip_details.booking_id
    group by day_type;
    
